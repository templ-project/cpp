version: '3'

vars:
  # mise dependent
  __TF_MISE_E: 'mise trust; mise exec --'
  __TF_MISE_E_PWSH: 'mise trust; mise exec -- pwsh -NoProfile -ExecutionPolicy Bypass -Command'
  __TF_MISE_E_PWSH_FILE: 'mise trust; mise exec -- pwsh -NoProfile -ExecutionPolicy Bypass -File'
  __TF_MISE_E_UV_RUN: 'mise trust; mise exec -- uv run'
  # os dependent
  __TF_COMMAND_WRAPPER:
    sh: |
      echo '{{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command{{else}}bash -c{{end}}'
  __TF_HEADER_LINE: '=============================================================='
  __TF_SEP: ' '
  __TF_VAR_PREFIX:
    sh: |
      echo "{{if eq OS "windows"}}\${{else}}{{end}}"

  # cpp project defaults
  __TF_VALIDATION_CPP_BUILD_SYSTEMS:
    sh: |
      echo "bazel cmake xmake"
  __TF_VALIDATION__CPP_COMPILERS:
    sh: |
      echo "clang++ {{if eq OS "windows"}}msvc{{else}}g++{{end}}"
  CPP_PROJECT_NAME: '{{default .CPP_PROJECT_NAME "cpp-template"}}'
  CPP_BUILD_SYSTEM: '{{default .CPP_BUILD_SYSTEM "cmake"}}'
  CPP_BUILD_DIR: '{{default .CPP_BUILD_DIR "build"}}'
  CPP_BUILD_TYPE: '{{default .CPP_BUILD_TYPE "Release"}}'
  CPP_COMPILER: '{{default .CPP_COMPILER "clang++"}}'

  # Build targets - loaded from .build-targets.yml
  CPP_BUILD_TARGETS_RAW:
    sh: cat .build-targets.yml
  CPP_BUILD_TARGETS:
    ref: '(fromYaml .CPP_BUILD_TARGETS_RAW).targets'

env:
  BAZEL_VC:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*\*\VC\Tools\MSVC' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).Parent.Parent.FullName"{{else}}echo ""{{end}}
  BAZEL_VC_FULL_VERSION:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*\*\VC\Tools\MSVC\*' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).Name"{{else}}echo ""{{end}}
  BAZEL_LLVM:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "try { (Get-Item (Get-Command clang++).Source).Directory.Parent.FullName } catch { echo '' }"{{else}}echo ""{{end}}
  CMAKE_VS_GENERATOR:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*' -Directory | Sort-Object Name | Select-Object -First 1).Name | ForEach-Object { if (\$_ -eq '2022') { 'Visual Studio 17 2022' } elseif (\$_ -eq '2019') { 'Visual Studio 16 2019' } elseif (\$_ -eq '2017') { 'Visual Studio 15 2017' } else { 'Visual Studio 17 2022' } }"{{else}}echo ""{{end}}
  SDKROOT:
    sh: |
      echo "{{if eq OS "darwin"}}/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk{{else}}$SDKROOT{{end}}"

tasks:
  # ==========================================================================
  # Generic Tasks
  # ==========================================================================

  print:env:
    cmds:
      - cmd: |
          {{.__TF_MISE_E}} env | sort
        platforms: [darwin, linux]
      - cmd: |
          {{.__TF_MISE_E}} {{ .__TF_SEP
            }}pwsh -Command '$BashPath=(Get-Command bash -ErrorAction SilentlyContinue).Path;{{ .__TF_SEP
              }}if ($BashPath) { & $BashPath -c "env | sort" }{{ .__TF_SEP
              }}else { Get-ChildItem "Env:" | Sort-Object Name | ForEach-Object { "$($_.Name)=$($_.Value)" } }'
        platforms: [windows]
    desc: 'Print current build environment variables'
    summary: |
      Print current build environment variables

      Displays all environment variables available during the build process,
      sorted alphabetically. Useful for debugging build issues and verifying
      tool configurations.

      Examples:
        task print:env

  # ==========================================================================
  # Build Tasks
  # ==========================================================================

  build:
    cmds:
      - cmd: |
          echo "{{.__TF_HEADER_LINE}}"
          echo "Compiling for {{OS}}/{{ARCH}}, using {{.CPP_BUILD_SYSTEM}} and {{.CPP_COMPILER}}"
          echo "{{.__TF_HEADER_LINE}}"
          {{if ne OS "windows"}}{{if eq .CPP_COMPILER "msvc"}}
            echo "‚ùå MSVC compiler is only supported on Windows."
            exit 1
          {{end}}{{end}}
      - task: print:env
      - task: 'build:{{.CPP_BUILD_SYSTEM}}'
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
          CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
    desc: 'Build project (system: {{.CPP_BUILD_SYSTEM}}, type: {{.CPP_BUILD_TYPE}})'
    sources:
      - include/**/*.h
      - include/**/*.hpp
      - src/**/*.cpp
      - src/**/*.hpp
      - tests/**/*.cpp
    summary: |
      Build the C++ project for the current platform

      Compiles the application using the configured build system and compiler.
      Automatically selects the appropriate build configuration based on
      environment variables.

      Variables:
        CPP_BUILD_SYSTEM: Build system to use (default: cmake)
                          Options: bazel, cmake, xmake
        CPP_BUILD_TYPE:   Build type (default: Release)
                          Options: Debug, Release
        CPP_COMPILER:     Compiler to use (default: clang++)
                          Options: clang++, g++, msvc (Windows only)
        CPP_BUILD_DIR:    Output directory for build artifacts (default: build)

      Examples:
        task build                              # Build with defaults
        task build CPP_BUILD_TYPE=Debug         # Build debug version
        task build CPP_BUILD_SYSTEM=bazel       # Build using Bazel
        task build CPP_COMPILER=g++             # Build with GCC

  build:all:
    cmds:
      - for:
          var: CPP_BUILD_TARGETS
        task: build:target
        vars:
          TARGET_ARCH: '{{.ITEM.arch}}'
          TARGET_OS: '{{.ITEM.os}}'
    desc: 'Build all architecture targets for current OS'
    summary: |
      Build all architecture targets for the current OS

      Iterates through targets defined in .build-targets.yml and builds
      all architectures that match the current operating system.
      Non-matching OS targets are automatically skipped.

      Output binaries are placed in build/<project>_<os>_<arch>[.exe].

      Examples:
        task build:all                         # Build all archs for current OS
        task build:all CPP_BUILD_TYPE=Debug    # Build all archs in debug mode

  build:target:
    cmds:
      - cmd: |
          # On macOS, skip if target arch doesn't match host arch
          # Cross-compilation is not supported with mise-managed LLVM because the
          # standalone LLVM distribution only includes libraries for the host architecture
          # (e.g., ARM64 LLVM has ARM64 libc++, not x86_64 libc++)
          {{if and (eq OS "darwin") (eq .TARGET_OS "darwin")}}
          if [ "{{.NORMALIZED_HOST_ARCH}}" != "{{.TARGET_ARCH}}" ]; then
            echo "‚è≠Ô∏è  Skipping {{.TARGET_OS}}/{{.TARGET_ARCH}} (host is {{.NORMALIZED_HOST_ARCH}}, cross-compile not supported with mise LLVM)"
            exit 0
          fi
          {{end}}
          echo "{{.__TF_HEADER_LINE}}"
          echo "Building {{.CPP_PROJECT_NAME}} for {{.TARGET_OS}}/{{.TARGET_ARCH}} in {{.CPP_BUILD_TYPE}} mode"
          echo "{{.__TF_HEADER_LINE}}"
      - task: 'build:target:impl'
        vars:
          ARCH_BUILD_DIR: '{{.ARCH_BUILD_DIR}}'
          CPP_BUILD_DIR: '{{.ARCH_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
          CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
          EXE_EXT: '{{.EXE_EXT}}'
          NORMALIZED_HOST_ARCH: '{{.NORMALIZED_HOST_ARCH}}'
          OUTPUT_NAME: '{{.OUTPUT_NAME}}'
          TARGET_ARCH: '{{.TARGET_ARCH}}'
          TARGET_OS: '{{.TARGET_OS}}'
    desc: 'Build for a specific OS/ARCH target'
    requires:
      vars: [TARGET_ARCH, TARGET_OS]
    status:
      # Skip if TARGET_OS doesn't match current OS
      - '[ "{{.TARGET_OS}}" != "{{OS}}" ]'
    summary: |
      Build for a specific OS/ARCH target

      Compiles the application for the specified operating system and
      architecture combination. Automatically skips if TARGET_OS doesn't
      match the current OS.

      On macOS, cross-architecture builds are NOT supported with mise-managed LLVM.
      The standalone LLVM distribution only includes libraries (libc++, libunwind, etc.)
      for the host architecture, so linking fails for non-native targets.
      The task will skip with a warning for non-matching architectures on macOS.

      Required Variables:
        TARGET_OS:   Target operating system (linux, darwin, windows)
        TARGET_ARCH: Target architecture (x86_64, aarch64)

      Note: This task is typically called by build:all, not directly.
    vars:
      ARCH_BUILD_DIR: 'build-{{.TARGET_ARCH}}'
      EXE_EXT: '{{if eq .TARGET_OS "windows"}}.exe{{end}}'
      # Normalize host arch: Taskfile uses arm64/amd64, our targets use aarch64/x86_64
      NORMALIZED_HOST_ARCH: '{{if eq ARCH "arm64"}}aarch64{{else if eq ARCH "amd64"}}x86_64{{else}}{{ARCH}}{{end}}'
      OUTPUT_NAME: '{{.CPP_PROJECT_NAME}}_{{.TARGET_OS}}_{{.TARGET_ARCH}}{{.EXE_EXT}}'

  build:target:impl:
    cmds:
      - task: 'build:target:clean'
        vars:
          ARCH_BUILD_DIR: '{{.ARCH_BUILD_DIR}}'
      - task: 'build:{{.CPP_BUILD_SYSTEM}}'
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
          CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
          TARGET_ARCH: '{{.TARGET_ARCH}}'
      - cmd: |
          {{if ne OS "windows"}}
          mkdir -p build
          # Find and copy the binary to build/ with proper naming
          {{if eq .CPP_BUILD_SYSTEM "bazel"}}
          cp bazel-bin/{{.CPP_PROJECT_NAME}}{{.EXE_EXT}} build/{{.OUTPUT_NAME}} 2>/dev/null || true
          {{else}}
          find {{.ARCH_BUILD_DIR}} -name "{{.CPP_PROJECT_NAME}}{{.EXE_EXT}}" -type f | head -n 1 | xargs -I{} cp {} build/{{.OUTPUT_NAME}} 2>/dev/null || true
          {{end}}
          {{else}}
          {{.__TF_COMMAND_WRAPPER}} '{{.__TF_VAR_PREFIX}}dummy=$null;{{.__TF_SEP}}if (-not (Test-Path build)) { New-Item -ItemType Directory -Path build -Force | Out-Null };{{.__TF_SEP}}{{if eq .CPP_BUILD_SYSTEM "bazel"}}Copy-Item -Path "bazel-bin/{{.CPP_PROJECT_NAME}}{{.EXE_EXT}}" -Destination "build/{{.OUTPUT_NAME}}" -ErrorAction SilentlyContinue{{else}}{{.__TF_VAR_PREFIX}}found = Get-ChildItem -Path "{{.ARCH_BUILD_DIR}}" -Recurse -Filter "{{.CPP_PROJECT_NAME}}{{.EXE_EXT}}" -ErrorAction SilentlyContinue | Select-Object -First 1;{{.__TF_SEP}}if ({{.__TF_VAR_PREFIX}}found) { Copy-Item -Path {{.__TF_VAR_PREFIX}}found.FullName -Destination "build/{{.OUTPUT_NAME}}" }{{end}}'
          {{end}}
          echo "Built: build/{{.OUTPUT_NAME}}"
    internal: true
    requires:
      vars:
        [
          ARCH_BUILD_DIR,
          CPP_BUILD_DIR,
          CPP_BUILD_SYSTEM,
          CPP_BUILD_TYPE,
          CPP_COMPILER,
          CPP_PROJECT_NAME,
          EXE_EXT,
          NORMALIZED_HOST_ARCH,
          OUTPUT_NAME,
          TARGET_ARCH,
          TARGET_OS,
        ]
    status:
      # On macOS, skip if target arch doesn't match host arch (mise LLVM lacks cross-arch libs)
      - '{{if and (eq OS "darwin") (eq .TARGET_OS "darwin")}}[ "{{.NORMALIZED_HOST_ARCH}}" != "{{.TARGET_ARCH}}" ]{{else}}false{{end}}'

  build:target:clean:
    cmds:
      - cmd: |
          # Clean build system caches/configs that may have wrong architecture
          rm -rf .xmake {{.ARCH_BUILD_DIR}}
          {{.__TF_MISE_E}} bazel clean 2>/dev/null || true
    desc: 'Clean build artifacts for a specific architecture target'
    internal: true
    requires:
      vars: [ARCH_BUILD_DIR]

  build:dist:
    cmds:
      - cmd: .scripts/build-dist.sh "{{.CPP_PROJECT_NAME}}"
        platforms: [darwin, linux]
      - cmd: '{{.__TF_MISE_E_PWSH_FILE}} .scripts/build-dist.ps1 -ProjectName "{{.CPP_PROJECT_NAME}}"'
        platforms: [windows]
    deps:
      - build:all
    desc: 'Create distribution archives for all builds in build/'
    sources:
      - build/*
    summary: |
      Create distribution archives for all builds

      Creates compressed archives for all binaries in the build/ directory.
      Unix binaries are packaged as .tar.gz, Windows binaries as .zip.
      Output archives are placed in dist/.

      Examples:
        task build:dist                      # Build all and create archives

  build:bazel:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} python .scripts/compile_templates.py --build-system bazel --compiler {{.CPP_COMPILER}}{{if .TARGET_ARCH}} --arch {{.TARGET_ARCH}}{{end}}
      - |
        BAZEL_CONFIG="{{if eq .CPP_BUILD_TYPE "Debug"}}--compilation_mode=dbg{{else}}--compilation_mode=opt{{end}}"
        {{.__TF_MISE_E}} bazel build //:{{.CPP_PROJECT_NAME}} $BAZEL_CONFIG

        # Generate compile_commands.json for clang-tidy using Hedron
        # Skip on macOS: mise LLVM has broken macOS SDK header integration (mbstate_t errors)
        # Skip with MSVC: Hedron doesn't support MSVC
        {{if and (ne OS "darwin") (ne .CPP_COMPILER "msvc")}}
        {{.__TF_MISE_E}} bazel run @hedron_compile_commands//:refresh_all
        {{end}}
    deps:
      - deps:sync:uv
    desc: 'Build project using Bazel'
    env:
      CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
      CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
      CPP_COMPILER: '{{.CPP_COMPILER}}'
      CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
    generates:
      - bazel-bin/{{.CPP_PROJECT_NAME}}
    sources:
      - .bazelrc
      - BUILD.bazel
      - MODULE.bazel
      - WORKSPACE
      - tests/BUILD.bazel
    summary: |
      Build project using Bazel build system

      Compiles the C++ project using Bazel with the configured compiler.
      Generates compile_commands.json for IDE integration using Hedron.

      Variables:
        CPP_BUILD_TYPE: Debug or Release (default: Release)
        CPP_COMPILER:   Compiler to use (default: clang++)

      Examples:
        task build:bazel                        # Build with Bazel
        task build:bazel CPP_BUILD_TYPE=Debug   # Debug build with Bazel

  build:cmake:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} python .scripts/compile_templates.py --build-system cmake --compiler {{.CPP_COMPILER}}{{if .TARGET_ARCH}} --arch {{.TARGET_ARCH}}{{end}}
      - |
        {{.__TF_MISE_E_UV_RUN}} cmake -B "{{.CPP_BUILD_DIR}}" -G "{{.CMAKE_GENERATOR}}" \
            -DCMAKE_BUILD_TYPE="{{.CPP_BUILD_TYPE}}" \
            {{.CMAKE_COMPILER_FLAG}} \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        {{.__TF_MISE_E_UV_RUN}} cmake --build "{{.CPP_BUILD_DIR}}" --parallel
    desc: 'Build project using CMake'
    env:
      CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
      CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
      CPP_COMPILER: '{{.CPP_COMPILER}}'
      CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
    generates:
      - '{{.CPP_BUILD_DIR}}/CMakeCache.txt'
      - '{{.CPP_BUILD_DIR}}/compile_commands.json'
    sources:
      - CMakeLists.txt
      - tests/CMakeLists.txt
    summary: |
      Build project using CMake build system

      Configures and builds the C++ project using CMake. Automatically
      selects the appropriate generator based on OS and compiler.
      Generates compile_commands.json for IDE integration.

      Variables:
        CPP_BUILD_TYPE: Debug or Release (default: Release)
        CPP_COMPILER:   Compiler to use (default: clang++)
        CPP_BUILD_DIR:  Output directory (default: build)

      Examples:
        task build:cmake                        # Build with CMake
        task build:cmake CPP_BUILD_TYPE=Debug   # Debug build with CMake
    vars:
      CMAKE_COMPILER_FLAG: '{{if eq .CPP_COMPILER "msvc"}}{{else}}-DCMAKE_CXX_COMPILER={{.CPP_COMPILER}}{{end}}'
      CMAKE_GENERATOR: '{{if eq OS "windows"}}{{if eq .CPP_COMPILER "msvc"}}{{.CMAKE_VS_GENERATOR}}{{else}}Ninja{{end}}{{else}}Unix Makefiles{{end}}'

  build:xmake:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} python .scripts/compile_templates.py --build-system xmake --compiler {{.CPP_COMPILER}}{{if .TARGET_ARCH}} --arch {{.TARGET_ARCH}}{{end}}
      - |
        {{.__TF_MISE_E}} xmake f -m {{.XMAKE_MODE}}{{if .XMAKE_ARCH}} -a {{.XMAKE_ARCH}}{{end}} -y
        {{.__TF_MISE_E}} xmake build -y
        {{.__TF_MISE_E}} xmake project -k compile_commands "{{.CPP_BUILD_DIR}}"
    desc: 'Build project using XMake'
    env:
      '{{if and (eq OS "windows") (eq .CPP_COMPILER "clang++")}}CXXFLAGS': '-Wno-error -Wno-unknown-warning-option'
      CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
      CPP_BUILD_TYPE: '{{.CPP_BUILD_TYPE}}'
      CPP_COMPILER: '{{.CPP_COMPILER}}'
      CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
    generates:
      - '{{.CPP_BUILD_DIR}}/compile_commands.json'
      - .xmake/cache/config
    sources:
      - xmake.lua
    summary: |
      Build project using XMake build system

      Configures and builds the C++ project using XMake. Generates
      compile_commands.json for IDE integration.

      Variables:
        CPP_BUILD_TYPE: Debug or Release (default: Release)
        CPP_COMPILER:   Compiler to use (default: clang++)
        CPP_BUILD_DIR:  Output directory (default: build)

      Examples:
        task build:xmake                        # Build with XMake
        task build:xmake CPP_BUILD_TYPE=Debug   # Debug build with XMake
    vars:
      XMAKE_ARCH: '{{if eq .TARGET_ARCH "aarch64"}}arm64{{else if eq .TARGET_ARCH "x86_64"}}x86_64{{end}}'
      XMAKE_MODE: '{{if eq .CPP_BUILD_TYPE "Debug"}}debug{{else}}release{{end}}'

  # ============================================================================
  # Clean Tasks
  # ============================================================================

  clean:
    cmds:
      - cmd: |
          # Clean Bazel cache if bazel is available
          if command -v bazel &> /dev/null || [ -f .mise.toml ]; then
            {{.__TF_MISE_E}} bazel clean 2>/dev/null || true
          fi

          rm -rf \
              .bazelrc \
              .cache \
              .coverage \
              .jscpd/html \
              .task \
              .xmake \
              {{.CPP_BUILD_DIR}} \
              build-* \
              BUILD.bazel \
              CMakeLists.txt \
              compile_commands.json \
              coverage \
              dist \
              docs-html \
              MODULE.bazel \
              src/CMakeLists.txt \
              tests/BUILD.bazel \
              WORKSPACE \
              xmake.lua

          find . -type d -name "bazel-*" | while read d; do rm -rf "$d"; done
      - cmd: |
          rm -rf ~/AppData/Local/Temp/.xmake*
          rm -rf ~/AppData/Local/Temp/*.il
        platforms: [windows]
    desc: 'Clean all build artifacts'
    summary: |
      Clean all build artifacts

      Removes all generated files and directories including:
        - build/        - Compiled binaries
        - build-*/      - Architecture-specific build directories
        - dist/         - Distribution archives
        - .task/        - Task cache
        - coverage/     - Test coverage reports
        - .jscpd/html   - Duplicate check reports
        - Generated build files (CMakeLists.txt, BUILD.bazel, etc.)
        - Bazel cache (via bazel clean)

      Examples:
        task clean                           # Remove all artifacts

  # ============================================================================
  # Code Quality Tasks
  # ============================================================================

  format:
    cmds:
      - task: format:clang
      - task: format:prettier
      - task: format:ruff
      - cmd: echo "‚úÖ Code format completed"
    desc: 'Format code and fix issues'
    summary: |
      Format all code in the project

      Runs all formatters in sequence:
        1. clang-format for C++ files
        2. Prettier for JSON, YAML, Markdown files
        3. Ruff for Python files

      Examples:
        task format                          # Format all code

  format:clang:
    cmds:
      - |
        {{.__TF_MISE_E}} python .scripts/format_clang.py --fix
    desc: 'Format C++ code using clang-format'
    silent: true
    summary: |
      Format C++ code using clang-format

      Formats all C++ source files (.cpp, .hpp, .h) using clang-format
      with the project's .clang-format configuration.

      Examples:
        task format:clang                    # Format C++ files

  format:prettier:
    cmds:
      - task: prettier
        vars:
          CLI_ARGS: '--write .'
    desc: 'Format code using Prettier'
    silent: true
    summary: |
      Format configuration files using Prettier

      Formats JSON, YAML, Markdown, and other supported files
      using Prettier with the project's configuration.

      Examples:
        task format:prettier                 # Format config files

  prettier:
    cmds:
      - |
        {{.__TF_MISE_E}} npx prettier {{.CLI_ARGS}}
      - echo "- ‚úÖ prettier format completed"
    silent: true
    sources:
      - '**/*.{json,md,toml,yaml,yml}'
    summary: |
      Run Prettier with custom arguments

      Internal task for running Prettier. Use format:prettier or
      format:check:prettier instead.

      Variables:
        CLI_ARGS: Arguments to pass to Prettier

  format:ruff:
    aliases: [format:py, format:python]
    cmds:
      - task: ruff
        vars:
          CLI_ARGS: 'format .'
      - echo "- ‚úÖ ruff format completed"
    desc: 'Format Python code using Ruff'
    silent: true
    summary: |
      Format Python code using Ruff

      Formats all Python files using Ruff formatter with the
      project's pyproject.toml configuration.

      Examples:
        task format:ruff                     # Format Python files
        task format:py                       # Alias
        task format:python                   # Alias

  ruff:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} ruff {{.CLI_ARGS}}
    desc: 'Run Ruff'
    silent: true
    sources:
      - '**/*.py'
    summary: |
      Run Ruff with custom arguments

      Internal task for running Ruff. Use format:ruff or
      lint:ruff instead.

      Variables:
        CLI_ARGS: Arguments to pass to Ruff

  format:check:
    cmds:
      - task: format:check:clang
      - task: format:check:prettier
      - task: format:check:ruff
      - cmd: echo "‚úÖ Code format check completed"
    desc: 'Check code formatting without fixing'
    summary: |
      Check code formatting without making changes

      Verifies all code is properly formatted without modifying files.
      Useful for CI pipelines to enforce formatting standards.

      Examples:
        task format:check                    # Check all formatting

  format:check:clang:
    cmds:
      - |
        {{.__TF_MISE_E}} python .scripts/format_clang.py --check
    desc: 'Check C++ code formatting using clang-format'
    silent: true
    summary: |
      Check C++ code formatting without fixing

      Verifies C++ files are properly formatted using clang-format.
      Exits with error if any files need formatting.

      Examples:
        task format:check:clang              # Check C++ formatting

  format:check:prettier:
    cmds:
      - task: prettier
        vars:
          CLI_ARGS: '--check .'
      - echo "- ‚úÖ prettier format check completed"
    desc: 'Check code formatting using Prettier'
    silent: true
    summary: |
      Check Prettier formatting without fixing

      Verifies configuration files are properly formatted.
      Exits with error if any files need formatting.

      Examples:
        task format:check:prettier           # Check Prettier formatting

  format:check:ruff:
    aliases: [format:check:py, format:check:python]
    cmds:
      - task: ruff
        vars:
          CLI_ARGS: 'format --check .'
      - echo "- ‚úÖ ruff format check completed"
    desc: 'Check Python code formatting using Ruff'
    silent: true
    summary: |
      Check Python code formatting without fixing

      Verifies Python files are properly formatted using Ruff.
      Exits with error if any files need formatting.

      Examples:
        task format:check:ruff               # Check Python formatting
        task format:check:py                 # Alias

  lint:
    cmds:
      - task: lint:clang
      - task: lint:eslint
      - task: lint:pylint
      - task: lint:pwshlint
      - task: lint:shlint
      - cmd: echo "‚úÖ Linting completed"
    desc: 'Run linter and fix issues'
    summary: |
      Run all linters and fix issues

      Runs all linters in sequence with auto-fix enabled:
        1. clang-tidy for C++ files
        2. ESLint for config files
        3. Pylint for Python files
        4. PSScriptAnalyzer for PowerShell files
        5. ShellCheck for shell scripts

      Examples:
        task lint                            # Lint and fix all code

  lint:clang:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} python .scripts/lint_clang.py --fix
      - echo "- ‚úÖ clang lint completed"
    deps:
      - task: build
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
    desc: 'Lint C++ code and fix issues'
    silent: true
    summary: |
      Lint C++ code using clang-tidy

      Analyzes C++ code for bugs, style issues, and performance
      problems. Requires compile_commands.json from a previous build.

      Examples:
        task lint:clang                      # Lint C++ with fixes

  lint:eslint:
    cmds:
      - task: eslint
        vars:
          CLI_ARGS: '--fix .'
      - echo "- ‚úÖ eslint lint completed"
    desc: 'Lint code using ESLint'
    silent: true
    summary: |
      Lint configuration files using ESLint

      Analyzes JSON, YAML, Markdown files for issues and
      automatically fixes what it can.

      Examples:
        task lint:eslint                     # Lint config files

  eslint:
    cmds:
      - |
        {{.__TF_MISE_E}} npx eslint {{.CLI_ARGS}}
    desc: 'Run ESLint'
    silent: true
    sources:
      - '**/*.{json,md,toml,yaml,yml}'
    summary: |
      Run ESLint with custom arguments

      Internal task for running ESLint. Use lint:eslint or
      lint:check:eslint instead.

      Variables:
        CLI_ARGS: Arguments to pass to ESLint

  lint:pylint:
    aliases: [lint:py, lint:python]
    cmds:
      - task: pylint
        vars:
          CLI_ARGS: '.'
      - echo "- ‚úÖ pylint lint completed"
    desc: 'Lint Python scripts using pylint'
    silent: true
    summary: |
      Lint Python code using Pylint

      Analyzes Python files for errors, coding standards,
      and code smells.

      Examples:
        task lint:pylint                     # Lint Python files
        task lint:py                         # Alias

  pylint:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} pylint {{.CLI_ARGS}}
    desc: 'Run pylint'
    silent: true
    sources:
      - '**/*.py'
    summary: |
      Run Pylint with custom arguments

      Internal task for running Pylint. Use lint:pylint instead.

      Variables:
        CLI_ARGS: Arguments to pass to Pylint

  lint:pwshlint:
    aliases: [lint:pwsh]
    cmds:
      - task: pwshlint_py
        vars:
          CLI_ARGS: '--fix'
      - echo "- ‚úÖ pwsh lint completed"
    desc: 'Lint PowerShell scripts using PSScriptAnalyzer'
    silent: true
    summary: |
      Lint PowerShell scripts using PSScriptAnalyzer

      Analyzes PowerShell files for best practices and
      common issues.

      Examples:
        task lint:pwshlint                   # Lint PowerShell files
        task lint:pwsh                       # Alias

  pwshlint_py:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} .scripts/pwshlint.py {{.CLI_ARGS}}
    desc: 'Run PSScriptAnalyzer'
    silent: true
    sources:
      - '**/*.ps1'
    summary: |
      Run PSScriptAnalyzer with custom arguments

      Internal task for running PSScriptAnalyzer.
      Use lint:pwshlint instead.

      Variables:
        CLI_ARGS: Arguments to pass to pwshlint.py

  lint:shlint:
    aliases: [lint:bash, lint:sh]
    cmds:
      - task: shlint_py
        vars:
          CLI_ARGS: '--fix'
      - echo "- ‚úÖ bash lint completed"
    desc: 'Lint shell scripts using ShellCheck'
    silent: true
    summary: |
      Lint shell scripts using ShellCheck

      Analyzes shell scripts for common bugs and
      portability issues.

      Examples:
        task lint:shlint                     # Lint shell scripts
        task lint:sh                         # Alias
        task lint:bash                       # Alias

  shlint_py:
    cmds:
      - cmd: |
          {{.__TF_MISE_E}} python .scripts/shlint.py {{.CLI_ARGS}}
        platforms: [darwin, linux, windows]
    desc: 'Run ShellCheck'
    silent: true
    sources:
      - '**/*.sh'
    summary: |
      Run ShellCheck with custom arguments

      Internal task for running ShellCheck.
      Use lint:shlint instead.

      Variables:
        CLI_ARGS: Arguments to pass to shlint.py

  lint:check:
    cmds:
      - task: lint:check:clang
      - task: lint:check:eslint
      - task: lint:check:pylint
      - task: lint:check:pwshlint
      - task: lint:check:shlint
      - cmd: echo "‚úÖ Linting check completed"
    desc: 'Run linter without fixing'
    summary: |
      Run all linters without fixing issues

      Checks code for linting issues without modifying files.
      Useful for CI pipelines to enforce coding standards.

      Examples:
        task lint:check                      # Check all linting

  lint:check:clang:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} python .scripts/lint_clang.py
      - echo "- ‚úÖ clang lint check completed"
    deps:
      - task: build
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
    desc: 'Check C++ code using clang-tidy'
    silent: true
    summary: |
      Check C++ code using clang-tidy without fixing

      Analyzes C++ code and reports issues without modifying files.

      Examples:
        task lint:check:clang                # Check C++ linting

  lint:check:eslint:
    cmds:
      - task: eslint
        vars:
          CLI_ARGS: '.'
      - echo "- ‚úÖ eslint lint check completed"
    desc: 'Check config files using eslint'
    silent: true
    summary: |
      Check ESLint without fixing

      Analyzes configuration files and reports issues.

      Examples:
        task lint:check:eslint               # Check ESLint

  lint:check:pylint:
    aliases: [lint:check:py, lint:check:python]
    cmds:
      - task: lint:pylint
      - echo "- ‚úÖ pylint lint check completed"
    desc: 'Check Python scripts using pylint'
    silent: true
    summary: |
      Check Python code using Pylint without fixing

      Analyzes Python files and reports issues.

      Examples:
        task lint:check:pylint               # Check Python linting
        task lint:check:py                   # Alias

  lint:check:pwshlint:
    aliases: [lint:check:pwsh]
    cmds:
      - task: pwshlint_py
      - echo "- ‚úÖ pwsh lint completed"
    desc: 'Check PowerShell scripts using PSScriptAnalyzer'
    silent: true
    summary: |
      Check PowerShell scripts without fixing

      Analyzes PowerShell files and reports issues.

      Examples:
        task lint:check:pwshlint             # Check PowerShell linting
        task lint:check:pwsh                 # Alias

  lint:check:shlint:
    aliases: [lint:check:bash, lint:check:sh]
    cmds:
      - task: shlint_py
      - echo "- ‚úÖ bash lint completed"
    desc: 'Check shell scripts using ShellCheck'
    silent: true
    summary: |
      Check shell scripts without fixing

      Analyzes shell scripts and reports issues.

      Examples:
        task lint:check:shlint               # Check shell linting
        task lint:check:sh                   # Alias

  lint-staged:
    cmds:
      - |
        {{.__TF_MISE_E}} npx -y lint-staged
    desc: 'Run linter on staged files and fix issues'
    silent: true
    summary: |
      Run linters on git staged files only

      Runs appropriate linters on files staged for commit.
      Used by pre-commit hooks for fast feedback.

      Examples:
        task lint-staged                     # Lint staged files

  duplicate-check:
    cmds:
      - |
        {{.__TF_MISE_E}} npm run duplicate-check
      - git add .jscpd/jscpd-badge.svg 2>/dev/null || true
    desc: 'Check for duplicate code using jscpd'
    summary: |
      Check for duplicate code using jscpd

      Scans the codebase for copy-pasted code blocks and
      generates a report. Updates the duplication badge.

      Examples:
        task duplicate-check                 # Check for duplicates

  # ============================================================================
  # Test Tasks
  # ============================================================================

  test:
    cmds:
      - task: test:{{.CPP_BUILD_SYSTEM}}
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
    deps:
      - task: build
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_BUILD_TYPE: Debug
          CPP_COMPILER: '{{.CPP_COMPILER}}'
    desc: 'Run tests (system: {{.CPP_BUILD_SYSTEM}})'
    silent: true
    summary: |
      Run tests for the C++ project

      Builds the project in Debug mode and runs all tests using
      the configured build system's test runner.

      Variables:
        CPP_BUILD_SYSTEM: Build system to use (default: cmake)
        CPP_COMPILER:     Compiler to use (default: clang++)

      Examples:
        task test                            # Run tests
        task test CPP_BUILD_SYSTEM=bazel     # Run tests with Bazel

  test:bazel:
    cmds:
      - cmd: |
          {{if eq OS "linux"}}
            {{if eq .CPP_COMPILER "g++"}}
          echo "üìä Running tests with coverage for g++..."
          {{.__TF_MISE_E}} bazel coverage //tests/... --config=coverage --nocache_test_results
            {{else}}
          echo "‚úÖ Running tests (coverage only supported with g++)..."
          {{.__TF_MISE_E}} bazel test //tests/... --test_output=errors
            {{end}}
          {{else}}
          echo "‚úÖ Running tests (coverage only supported on Linux with g++)..."
          {{.__TF_MISE_E}} bazel test //tests/... --test_output=errors
          {{end}}
        platforms: [darwin, linux]
      - cmd: |
          {{.__TF_MISE_E}} bazel test //tests/... --test_output=errors
        platforms: [windows]
      - task: test:gen-coverage
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
      - echo "- ‚úÖ tests completed"
    desc: 'Run tests with Bazel'
    silent: true
    summary: |
      Run tests using Bazel test runner

      Runs all tests in the tests/ directory using Bazel.
      Coverage is generated on Linux with g++ compiler.

      Examples:
        task test:bazel                      # Run Bazel tests

  test:cmake:
    cmds:
      - |
        cd {{.CPP_BUILD_DIR}} && {{.__TF_MISE_E_UV_RUN}} ctest --output-on-failure {{if eq .CPP_COMPILER "msvc"}}-C Debug{{end}}
      - task: test:gen-coverage
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
      - echo "- ‚úÖ tests completed"
    desc: 'Run tests with CMake'
    silent: true
    summary: |
      Run tests using CTest (CMake test runner)

      Runs all tests using CTest with verbose output on failure.
      Generates coverage report if compiler supports it.

      Examples:
        task test:cmake                      # Run CMake tests

  test:xmake:
    cmds:
      - |
        {{.__TF_MISE_E}} xmake run -y {{.CPP_PROJECT_NAME}}-tests
      - task: test:gen-coverage
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}/{{.XMAKE_MODE}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_COMPILER: '{{.CPP_COMPILER}}'
      - echo "- ‚úÖ tests completed"
    desc: 'Run tests with XMake'
    silent: true
    summary: |
      Run tests using XMake test runner

      Runs the test executable built by XMake.
      Generates coverage report if compiler supports it.

      Examples:
        task test:xmake                      # Run XMake tests
    vars:
      XMAKE_MODE: '{{if eq .CPP_BUILD_TYPE "Debug"}}debug{{else}}release{{end}}'

  test:gen-coverage:
    cmds:
      - cmd: |
          {{if eq .CPP_COMPILER "msvc"}}
          echo "‚ö†Ô∏è Coverage generation is not supported with MSVC. Skipping."
          exit 0
          {{end}}
        platforms: [windows]
      - cmd: |
          {{if eq .CPP_BUILD_SYSTEM "bazel"}}
            {{if or (ne .CPP_COMPILER "g++") (ne OS "linux")}}
          echo "‚ö†Ô∏è Bazel coverage is only supported with g++ on Linux. Skipping."
          exit 0
            {{end}}

          if [ ! -f "bazel-out/_coverage/_coverage_report.dat" ]; then
            echo "‚ö†Ô∏è No coverage data found. Did coverage run successfully?"
            exit 0
          fi

          if ! command -v genhtml >/dev/null 2>&1; then
            echo "‚ö†Ô∏è genhtml not found. Install: sudo apt-get install lcov"
            exit 1
          fi

          echo "üìä Coverage Summary (Source Files Only):"
          if command -v lcov >/dev/null 2>&1; then
            lcov --list bazel-out/_coverage/_coverage_report.dat 2>/dev/null | \
              tail -n +3 | \
              grep -v -E "(tests/|integration/|unit/)" | \
              grep -v "^Executed" | \
              grep -v "^Test cases" || \
              lcov --list bazel-out/_coverage/_coverage_report.dat 2>/dev/null | tail -n +3
          fi

          mkdir -p coverage
          if ! genhtml bazel-out/_coverage/_coverage_report.dat \
            --output-directory coverage \
            --branch-coverage \
            --highlight \
            --legend \
            --ignore-errors empty \
            --quiet 2>/dev/null; then
            echo "‚ö†Ô∏è Failed to generate coverage report. The coverage data may be empty."
            exit 0
          fi

          echo "‚úÖ HTML coverage report: coverage/index.html"
          exit 0
          {{end}}
        platforms: [darwin, linux]
      - cmd: |
          {{if or (eq .CPP_BUILD_SYSTEM "cmake") (eq .CPP_BUILD_SYSTEM "xmake")}}
            {{if eq .CPP_COMPILER "msvc"}}
          echo "‚ö†Ô∏è Coverage is not supported with MSVC. Skipping."
          exit 0
            {{end}}

          echo "üìä Generating coverage report..."

          GCOV_EXEC="gcov"
          {{if eq .CPP_COMPILER "clang++"}}
          if command -v llvm-cov >/dev/null 2>&1; then
            GCOV_EXEC="llvm-cov gcov"
            echo "‚ÑπÔ∏è Using llvm-cov for clang++ coverage"
          else
            echo "‚ö†Ô∏è Warning: llvm-cov not found, coverage may fail with clang++"
          fi
          {{else if eq .CPP_COMPILER "g++"}}
          CXX_VERSION=$({{.CPP_COMPILER}} -dumpversion | cut -d. -f1)
          if command -v "gcov-$CXX_VERSION" >/dev/null 2>&1; then
            GCOV_EXEC="gcov-$CXX_VERSION"
            echo "‚ÑπÔ∏è Using $GCOV_EXEC to match {{.CPP_COMPILER}} version $CXX_VERSION"
          else
            echo "‚ö†Ô∏è Warning: gcov-$CXX_VERSION not found, using default gcov"
          fi
          {{end}}

          {{.__TF_MISE_E_UV_RUN}} gcovr --root . \
            --filter 'src/.*' --filter 'include/.*' \
            --exclude 'tests/.*' --exclude 'build/_deps/.*' \
            --gcov-executable "$GCOV_EXEC" \
            --gcov-ignore-errors=no_working_dir_found \
            --txt

          mkdir -p coverage
          {{.__TF_MISE_E_UV_RUN}} gcovr --root . \
            --filter 'src/.*' --filter 'include/.*' \
            --exclude 'tests/.*' --exclude 'build/_deps/.*' \
            --gcov-executable "$GCOV_EXEC" \
            --gcov-ignore-errors=no_working_dir_found \
            --html-details coverage/index.html 2>/dev/null
          echo "‚úÖ HTML coverage report: coverage/index.html"
          {{end}}
        platforms: [darwin, linux]
      - cmd: |
          {{if or (eq .CPP_BUILD_SYSTEM "cmake") (eq .CPP_BUILD_SYSTEM "xmake")}}
            {{if eq .CPP_COMPILER "msvc"}}
          echo "‚ö†Ô∏è Coverage is not supported with MSVC. Skipping."
          exit 0
            {{end}}
          {{end}}
        platforms: [windows]
    desc: 'Generate coverage report'
    silent: true
    summary: |
      Generate test coverage report

      Generates HTML coverage reports from test runs.
      Coverage support varies by build system and compiler:
        - Bazel: g++ on Linux only
        - CMake/XMake: clang++ or g++ (not MSVC)

      Output is placed in coverage/index.html.

      Examples:
        task test:gen-coverage               # Generate coverage

  # ============================================================================
  # Development Tools
  # ============================================================================

  run:
    cmds:
      - |
        echo "üèÉ Running application..."
        {{.__TF_COMMAND_WRAPPER}} '{{
          .__TF_VAR_PREFIX}}BUILD_PATH="{{if eq .CPP_BUILD_SYSTEM "bazel"}}bazel-out{{else}}{{.CPP_BUILD_DIR}}{{end}}";{{.__TF_SEP}}{{
            if ne OS "windows"}}eval $(find ./$BUILD_PATH/{{if eq .CPP_BUILD_SYSTEM "bazel"}}*-opt{{end}} -type f -name {{.CPP_PROJECT_NAME}} | head -n 1){{
            else}}(Get-ChildItem ./$BUILD_PATH{{if eq .CPP_BUILD_SYSTEM "bazel"}}/*-opt/bin{{end}} -Recurse -Filter {{
              .CPP_PROJECT_NAME}}.exe | Select-Object -First 1).FullName | ForEach-Object { & $_ }{{
            end}}'
    deps:
      - task: build
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_PROJECT_NAME: '{{.CPP_PROJECT_NAME}}'
    desc: 'Run application'
    summary: |
      Build and run the application

      Builds the project in Release mode and runs the resulting
      binary. Automatically locates the binary in the build output.

      Examples:
        task run                             # Build and run
        task run CPP_BUILD_SYSTEM=bazel      # Run Bazel build

  debug:
    cmds:
      - cmd: |
          {{if eq OS "windows"}}
          echo "‚ö†Ô∏è CLI debugging not supported on Windows."
          echo "‚ÑπÔ∏è Please use Visual Studio or your IDE's debugger instead."
          echo ""
          echo "Alternatively, install gdb via MSYS2 and run manually:"
          {{.__TF_COMMAND_WRAPPER}} '{{
            .__TF_VAR_PREFIX}}BUILD_PATH="{{if eq .CPP_BUILD_SYSTEM "bazel"}}bazel-out{{else}}{{.CPP_BUILD_DIR}}{{end}}";{{.__TF_SEP}}{{
              }}(Get-ChildItem ./$BUILD_PATH{{if eq .CPP_BUILD_SYSTEM "bazel"}}/*-dbg/bin{{end}} -Recurse -Filter {{
                .CPP_PROJECT_NAME}}.exe | Select-Object -First 1).FullName | ForEach-Object { Write-Host "gdb `"$_`"" }'
          exit 0
          {{else}}
          if command -v lldb >/dev/null 2>&1; then
            echo "üêõ Starting lldb debugger..."
            lldb $(find ./{{if eq .CPP_BUILD_SYSTEM "bazel"}}bazel-out/*-dbg{{else}}{{.CPP_BUILD_DIR}}{{end}} -name {{.CPP_PROJECT_NAME}} | head -n 1)
          elif command -v gdb >/dev/null 2>&1; then
            echo "üêõ Starting gdb debugger..."
            gdb $(find ./{{if eq .CPP_BUILD_SYSTEM "bazel"}}bazel-out/*-dbg{{else}}{{.CPP_BUILD_DIR}}{{end}} -name {{.CPP_PROJECT_NAME}} | head -n 1)
          else
            echo "‚ö†Ô∏è No debugger found. Please install gdb or lldb."
            exit 1
          fi
          {{end}}
    deps:
      - task: build
        vars:
          CPP_BUILD_DIR: '{{.CPP_BUILD_DIR}}'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_BUILD_TYPE: Debug
          CPP_COMPILER: '{{.CPP_COMPILER}}'
    desc: 'Run application with debugger (gdb/lldb)'
    summary: |
      Build and run application with debugger

      Builds the project in Debug mode and launches it in a debugger.
      Uses lldb on macOS, gdb on Linux. Windows users should use
      Visual Studio or their IDE's debugger.

      Examples:
        task debug                           # Build and debug

  # ============================================================================
  # Documentation Tasks
  # ============================================================================

  docs:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} mkdocs build
    desc: 'Build documentation'
    summary: |
      Build project documentation

      Generates static HTML documentation from Markdown files
      using MkDocs. Output is placed in docs-html/.

      Examples:
        task docs                            # Build docs

  docs:serve:
    cmds:
      - |
        echo "üìö Starting documentation server..."
        echo "üìñ Open http://127.0.0.1:8000 in your browser"
        {{.__TF_MISE_E_UV_RUN}} mkdocs serve
    desc: 'Serve documentation locally with live reload'
    summary: |
      Serve documentation with live reload

      Starts a local development server for documentation.
      Changes to Markdown files are reflected immediately.

      Examples:
        task docs:serve                      # Start docs server

  docs:deploy:
    cmds:
      - |
        {{.__TF_MISE_E_UV_RUN}} mkdocs gh-deploy --force
    desc: 'Deploy documentation to GitHub Pages'
    summary: |
      Deploy documentation to GitHub Pages

      Builds documentation and pushes to the gh-pages branch
      for hosting on GitHub Pages.

      Examples:
        task docs:deploy                     # Deploy to GitHub Pages

  # ============================================================================
  # Validation Tasks
  # ============================================================================

  validate:
    cmds:
      - for:
          var: __TF_VALIDATION_CPP_BUILD_SYSTEMS
          split: ' '
        task: validate:by:build-system
        vars:
          CPP_BUILD_SYSTEM: '{{.ITEM}}'
    desc: 'Run integration tests for all build systems'
    silent: true
    summary: |
      Run full validation for all build systems

      Runs the complete CI pipeline for each build system
      (bazel, cmake, xmake) with each compatible compiler.

      This is a comprehensive test that takes significant time.

      Examples:
        task validate                        # Validate all systems

  validate:by:build-system:
    cmds:
      - for:
          var: __TF_VALIDATION__CPP_COMPILERS
          split: ' '
        task: validate:by:build-system:compiler
        vars:
          CPP_BUILD_DIR: 'build'
          CPP_BUILD_SYSTEM: '{{.CPP_BUILD_SYSTEM}}'
          CPP_COMPILER: '{{.ITEM}}'
          CPP_PROJECT_NAME: 'cpp-template'
    desc: 'Run CI pipeline for specific build system'
    silent: true
    summary: |
      Run validation for a specific build system

      Runs the CI pipeline for the specified build system
      with all compatible compilers.

      Variables:
        CPP_BUILD_SYSTEM: Build system to validate

      Examples:
        task validate:by:build-system CPP_BUILD_SYSTEM=cmake

  validate:by:build-system:compiler:
    cmds:
      - task: format
      - task: clean
      - task: build:dist
      - task: clean
      - task: build
      - task: lint
      - task: run
      - task: clean
      - task: test
      # TODO: Enable docs generation in validation once we find a way to install doxygen cross OS
      # - task: docs
      - cmd: |
          echo ""
          echo "{{.__TF_HEADER_LINE}}"
          echo "‚úÖ Validation successful for {{.CPP_BUILD_SYSTEM}} with {{.CPP_COMPILER}}"
          echo "{{.__TF_HEADER_LINE}}"
          echo ""
    desc: 'Run CI pipeline for specific build system and compiler'
    silent: true
    summary: |
      Run validation for specific build system and compiler

      Runs the complete CI pipeline:
        1. Format code
        2. Clean build artifacts
        3. Build project
        4. Run linters
        5. Run application
        6. Clean and rebuild for tests
        7. Run tests
        8. Build documentation

      Variables:
        CPP_BUILD_SYSTEM: Build system to use
        CPP_COMPILER:     Compiler to use

      Examples:
        task validate:by:build-system:compiler \
          CPP_BUILD_SYSTEM=cmake CPP_COMPILER=clang++

  # ============================================================================
  # Dependencies
  # ============================================================================

  deps:clean:
    cmds:
      - task: deps:clean:mise
      - task: deps:clean:npm
      - task: deps:clean:uv
    desc: 'Clean all project dependencies'
    summary: |
      Clean all project dependencies

      Removes all installed dependencies:
        - Mise tool installations
        - Node.js node_modules
        - Python virtual environment

      Examples:
        task deps:clean                      # Clean all deps

  deps:clean:mise:
    cmds:
      - echo "üßπ Cleaning Mise dependencies..."
      - cmd: |
          rm -rf \
            ~/.local/share/mise/installs \
            ~/AppData/mise/installs
      - echo "‚úì Mise environment cleaned"
    desc: 'Clean Mise dependencies'
    summary: |
      Clean Mise tool installations

      Removes all tools installed by Mise from the global
      installation directory.

      Examples:
        task deps:clean:mise                 # Clean Mise tools

  deps:clean:npm:
    cmds:
      - |
        echo "üßπ Cleaning NodeJs dependencies..."
        rm -rf node_modules package-lock.json
        echo "‚úì NodeJs environment cleaned"
    desc: 'Clean NodeJs dependencies'
    summary: |
      Clean Node.js dependencies

      Removes node_modules directory and package-lock.json.

      Examples:
        task deps:clean:npm                  # Clean npm deps

  deps:clean:uv:
    cmds:
      - |
        echo "üßπ Cleaning Python dependencies..."
        rm -rf .venv uv.lock
        echo "‚úì Python environment cleaned"
    desc: 'Clean Python dependencies'
    summary: |
      Clean Python dependencies

      Removes the virtual environment and uv lock file.

      Examples:
        task deps:clean:uv                   # Clean Python deps

  deps:sync:
    cmds:
      - task: deps:sync:mise
      - task: deps:sync:npm
      - task: deps:sync:uv
    desc: 'Install all project dependencies'
    summary: |
      Install all project dependencies

      Installs all dependencies in order:
        1. Mise tools (compilers, build systems)
        2. Node.js packages (linters, formatters)
        3. Python packages (build scripts, docs)

      Examples:
        task deps:sync                       # Install all deps

  deps:sync:mise:
    cmds:
      - |
        echo "üì¶ Installing Mise dependencies..."
        mise trust && mise install --yes
        echo "‚úì Mise environment ready"
    desc: 'Install Mise dependencies'
    summary: |
      Install Mise tool dependencies

      Installs all tools defined in .mise.toml including
      compilers, build systems, and development tools.

      Examples:
        task deps:sync:mise                  # Install Mise tools

  deps:sync:npm:
    cmds:
      - |
        echo "üì¶ Installing NodeJs dependencies..."
        {{.__TF_MISE_E}} npm install
        {{.__TF_MISE_E}} npx husky
        echo "‚úì NodeJs environment ready"
    desc: 'Install NodeJs dependencies'
    summary: |
      Install Node.js dependencies

      Installs npm packages from package.json and sets up
      Husky git hooks.

      Examples:
        task deps:sync:npm                   # Install npm packages

  deps:sync:uv:
    cmds:
      - |
        echo "üì¶ Installing Python dependencies..."
        {{.__TF_MISE_E}} uv sync
        echo "‚úì Python environment ready"
    desc: 'Install Python dependencies'
    summary: |
      Install Python dependencies

      Creates a virtual environment and installs packages
      from pyproject.toml using uv.

      Examples:
        task deps:sync:uv                    # Install Python packages

  deps:refresh:
    cmds:
      - task: deps:refresh:mise
      - task: deps:refresh:npm
      - task: deps:refresh:uv
    desc: 'Refresh all project dependencies'
    summary: |
      Update all project dependencies

      Updates all dependencies to their latest compatible versions:
        1. Mise tools
        2. Node.js packages
        3. Python packages

      Examples:
        task deps:refresh                    # Update all deps

  deps:refresh:mise:
    cmds:
      - |
        echo "üîÑ Refreshing Mise packages..."
        touch mise.lock
        mise trust && mise upgrade
        echo "‚úì Packages refreshed"
    desc: 'Refresh all Mise packages (update dependencies)'
    summary: |
      Update Mise tools to latest versions

      Upgrades all Mise-managed tools to their latest versions
      as allowed by .mise.toml constraints.

      Examples:
        task deps:refresh:mise               # Update Mise tools

  deps:refresh:npm:
    cmds:
      - |
        echo "üîÑ Refreshing NodeJs packages..."
        {{.__TF_MISE_E}} npm outdated \
          && {{.__TF_MISE_E}} npm update \
          && {{.__TF_MISE_E}} npm audit fix
        echo "‚úì Packages refreshed"
    desc: 'Refresh all NodeJs packages (update dependencies)'
    summary: |
      Update Node.js packages to latest versions

      Shows outdated packages, updates them, and runs
      security audit fixes.

      Examples:
        task deps:refresh:npm                # Update npm packages

  deps:refresh:uv:
    cmds:
      - |
        echo "üîÑ Refreshing Python packages..."
        {{.__TF_MISE_E}} uv sync --upgrade
        echo "‚úì Packages refreshed"
    desc: 'Refresh all Python packages (update dependencies)'
    summary: |
      Update Python packages to latest versions

      Updates all Python packages to their latest versions
      as allowed by pyproject.toml constraints.

      Examples:
        task deps:refresh:uv                 # Update Python packages
