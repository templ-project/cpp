version: "3"

vars:
  __TF_COMMAND_WRAPPER:
    sh: |
      echo '{{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command{{else}}bash -c{{end}}'
  __TF_VAR_PREFIX:
    sh: |
      echo "{{if eq OS "windows"}}\${{else}}{{end}}"
  __TF_DUMMY_SPACE: " "
  __TF_HEADER_LINE: "=============================================================="
  __TF_VALIDATION_CPP_BUILD_SYSTEMS:
    sh: |
      echo "bazel cmake"
      # echo "bazel cmake xmake"
  __TF_VALIDATION__CPP_COMPILERS:
    sh: |
      echo "clang++ {{if eq OS "windows"}}msvc{{else}}g++{{end}}"

  CPP_PROJECT_NAME: '{{default .CPP_PROJECT_NAME "cpp-template"}}'
  CPP_BUILD_SYSTEM: '{{default .CPP_BUILD_SYSTEM "cmake"}}' # bazel, cmake, xmake
  CPP_BUILD_DIR: '{{default .CPP_BUILD_DIR "build"}}'
  CPP_BUILD_TYPE: '{{default .CPP_BUILD_TYPE "Release"}}'
  CPP_COMPILER: '{{default .CPP_COMPILER "clang++"}}' # clang++, g++, msvc (windows)

env:
  BAZEL_VC:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*\*\VC\Tools\MSVC' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).Parent.Parent.FullName"{{else}}echo ""{{end}}
  BAZEL_VC_FULL_VERSION:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*\*\VC\Tools\MSVC\*' | Sort-Object LastWriteTime -Descending | Select-Object -First 1).Name"{{else}}echo ""{{end}}
  BAZEL_LLVM:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "try { (Get-Item (Get-Command clang++).Source).Directory.Parent.FullName } catch { Write-Host '' }"{{else}}echo ""{{end}}
  CMAKE_VS_GENERATOR:
    sh: |
      {{if eq OS "windows"}}powershell -ExecutionPolicy Bypass -Command "(Get-ChildItem 'C:\Program Files*\Microsoft Visual Studio\*' -Directory | Sort-Object Name | Select-Object -First 1).Name | ForEach-Object { if (\$_ -eq '2022') { 'Visual Studio 17 2022' } elseif (\$_ -eq '2019') { 'Visual Studio 16 2019' } elseif (\$_ -eq '2017') { 'Visual Studio 15 2017' } else { 'Visual Studio 17 2022' } }"{{else}}echo ""{{end}}

tasks:
  # ==========================================================================
  # Build Tasks
  # ==========================================================================

  print:env:
    desc: "Print current build environment variables"
    cmds:
      - cmd: env
        platforms: [darwin, linux]
      - cmd: powershell -Command "Get-ChildItem Env:"
        platforms: [windows]

  build:
    desc: "Build project (system: {{.CPP_BUILD_SYSTEM}}, type: {{.CPP_BUILD_TYPE}})"
    cmds:
      - cmd: |
          echo "{{.__TF_HEADER_LINE}}"
          echo "Compiling for {{OS}}/{{ARCH}}, using {{.CPP_BUILD_SYSTEM}} and {{.CPP_COMPILER}}"
          echo "{{.__TF_HEADER_LINE}}"
          {{if ne OS "windows"}}{{if eq .CPP_COMPILER "msvc"}}
            echo "‚ùå MSVC compiler is only supported on Windows."
            exit 1
          {{end}}{{end}}
      - task: print:env
      - task: "build:{{.CPP_BUILD_SYSTEM}}"
        vars:
          CPP_BUILD_TYPE: "{{.CPP_BUILD_TYPE}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
    sources:
      - src/**/*.cpp
      - src/**/*.hpp
      - include/**/*.hpp
      - include/**/*.h
      - tests/**/*.cpp

  build:bazel:
    desc: "Build project using Bazel"
    sources:
      - BUILD.bazel
      - tests/BUILD.bazel
      - .bazelrc
      - MODULE.bazel
      - WORKSPACE
    generates:
      - bazel-bin/{{.CPP_PROJECT_NAME}}
    env:
      CPP_BUILD_TYPE: "{{.CPP_BUILD_TYPE}}"
      CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
      CPP_COMPILER: "{{.CPP_COMPILER}}"
      CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
    cmds:
      - python scripts/compile_templates.py --build-system bazel --compiler {{.CPP_COMPILER}}
      - |
        BAZEL_CONFIG="{{if eq .CPP_BUILD_TYPE "Debug"}}--compilation_mode=dbg{{else}}--compilation_mode=opt{{end}}"
        bazel build //:{{.CPP_PROJECT_NAME}} $BAZEL_CONFIG

        # Generate compile_commands.json for clang-tidy using Hedron
        {{if ne .CPP_COMPILER "msvc"}}
        bazel run @hedron_compile_commands//:refresh_all
        {{end}}

  build:cmake:
    desc: "Build project using CMake"
    sources:
      - CMakeLists.txt
      - tests/CMakeLists.txt
    generates:
      - "{{.CPP_BUILD_DIR}}/CMakeCache.txt"
      - "{{.CPP_BUILD_DIR}}/compile_commands.json"
    env:
      CPP_BUILD_TYPE: "{{.CPP_BUILD_TYPE}}"
      CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
      CPP_COMPILER: "{{.CPP_COMPILER}}"
      CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
    vars:
      CMAKE_GENERATOR: '{{if eq OS "windows"}}{{if eq .CPP_COMPILER "msvc"}}{{.CMAKE_VS_GENERATOR}}{{else}}Ninja{{end}}{{else}}Unix Makefiles{{end}}'
      CMAKE_COMPILER_FLAG: '{{if eq .CPP_COMPILER "msvc"}}{{else}}-DCMAKE_CXX_COMPILER={{.CPP_COMPILER}}{{end}}'
    cmds:
      - python scripts/compile_templates.py --build-system cmake --compiler {{.CPP_COMPILER}}
      - |
        cmake -B "{{.CPP_BUILD_DIR}}" -G "{{.CMAKE_GENERATOR}}" \
            -DCMAKE_BUILD_TYPE="{{.CPP_BUILD_TYPE}}" \
            {{.CMAKE_COMPILER_FLAG}} \
            -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
        cmake --build "{{.CPP_BUILD_DIR}}" --parallel

  build:xmake:
    desc: "Build project using XMake"
    sources:
      - xmake.lua
    generates:
      - .xmake/cache/config
      - "{{.CPP_BUILD_DIR}}/compile_commands.json"
    env:
      CPP_BUILD_TYPE: "{{.CPP_BUILD_TYPE}}"
      CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
      CPP_COMPILER: "{{.CPP_COMPILER}}"
      CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
    cmds:
      - python scripts/compile_templates.py --build-system xmake --compiler {{.CPP_COMPILER}}
      - |
        XMAKE_ARGS=""
        XMAKE_TOOLCHAIN="clang"

        # Windows-specific toolchain selection
        {{if eq OS "windows"}}
          if [ "{{.CPP_COMPILER}}" = "msvc" ]; then
            XMAKE_TOOLCHAIN="msvc"
          else
            XMAKE_TOOLCHAIN="clang"
          fi
        {{end}}

        # Coverage flags (skip for MSVC)
        if [ "{{.CPP_BUILD_TYPE}}" = "Debug" ] && [ "{{.CPP_COMPILER}}" != "msvc" ]; then
            XMAKE_ARGS='--cxflags=--coverage --ldflags=--coverage'
        fi

        xmake f -m $(echo "{{.CPP_BUILD_TYPE}}" | tr '[:upper:]' '[:lower:]') \
            $XMAKE_ARGS \
            --toolchain=$XMAKE_TOOLCHAIN -y
        xmake build
        xmake project -k compile_commands "{{.CPP_BUILD_DIR}}"

  build:detect:msvc:
    desc: "Detect MSVC compiler on Windows and display configuration"
    cmds:
      - |
        {{if eq OS "windows"}}
        echo "üîç Detecting Visual Studio installation..."
        echo "VC Path: $BAZEL_VC"
        echo "VC Version: $BAZEL_VC_FULL_VERSION"
        echo "Compiler: {{.CPP_COMPILER}}"

        # Test if MSVC is accessible
        if [ "{{.CPP_COMPILER}}" = "msvc" ]; then
          powershell -Command "if (Test-Path '$env:BAZEL_VC\\bin\\Hostx64\\x64\\cl.exe') { Write-Host '‚úÖ MSVC cl.exe found' } else { Write-Host '‚ùå MSVC cl.exe not found' }"
        fi
        {{else}}
        echo "‚ÑπÔ∏è MSVC detection is only available on Windows"
        {{end}}

  # ============================================================================
  # Clean Tasks
  # ============================================================================

  clean:
    desc: "Clean all build artifacts"
    cmds:
      - |
        rm -rf \
            .bazelrc \
            .cache \
            .coverage \
            .jscpd/html \
            .task \
            .xmake \
            {{.CPP_BUILD_DIR}} \
            BUILD.bazel \
            tests/BUILD.bazel \
            CMakeLists.txt \
            MODULE.bazel \
            WORKSPACE \
            compile_commands.json \
            docs-html \
            node_modules \
            package-lock.json \
            src/CMakeLists.txt \
            xmake.lua

        find . -type d -name "bazel-*" | while read d; do rm -rf "$d"; done

  # docs:
  #   desc: "Generate documentation with Doxygen"
  #   deps:
  #     - task: which
  #       vars:
  #         COMMAND: "doxygen"
  #   cmds:
  #     - doxygen Doxyfile

  # duplicate-check:
  #   desc: "Check for duplicate code using jscpd"
  #   deps:
  #     - task: which
  #       vars:
  #         COMMAND: "node"
  #   cmds:
  #     - cmd: |
  #         [ ! -d ./node_modules ] && npm install jscpd  @jscpd/badge-reporter

  #         mise exec -- npx jscpd src/ include/

  #         git add .jscpd/jscpd-badge.svg 2>/dev/null || true

  # ============================================================================
  # Code Quality Tasks
  # ============================================================================

  format:
    desc: "Format code and fix issues"
    cmds:
      - |
        SCRIPT_ARGS="--fix"
        python scripts/format.py $SCRIPT_ARGS

  format:check:
    desc: "Check code formatting without fixing"
    cmds:
      - python scripts/format.py

  lint:
    desc: "Run linter and fix issues"
    deps:
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
    cmds:
      - |
        # Bazel generates compile_commands.json at project root, others use build dir
        LINT_BUILD_DIR="{{.CPP_BUILD_DIR}}"
        if [ "{{.CPP_BUILD_SYSTEM}}" = "bazel" ]; then
            LINT_BUILD_DIR="."
        fi
        python scripts/lint.py --build-dir "$LINT_BUILD_DIR" --fix

  lint:check:
    desc: "Run linter without fixing"
    deps:
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
    cmds:
      - |
        # Bazel generates compile_commands.json at project root, others use build dir
        LINT_BUILD_DIR="{{.CPP_BUILD_DIR}}"
        if [ "{{.CPP_BUILD_SYSTEM}}" = "bazel" ]; then
            LINT_BUILD_DIR="."
        fi
        python scripts/lint.py --build-dir "$LINT_BUILD_DIR"

  duplicate-check:
    desc: "Check for duplicate code using jscpd"
    cmds:
      - "[ ! -d ./node_modules ] && npm install jscpd @jscpd/badge-reporter"
      - npx jscpd src/ include/
      - git add .jscpd/jscpd-badge.svg 2>/dev/null || true

  # ============================================================================
  # Test Tasks
  # ============================================================================

  test:
    desc: "Run tests (system: {{.CPP_BUILD_SYSTEM}})"
    vars:
      TEST_BUILD_TYPE: Debug
    cmds:
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_TYPE: "Debug"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
      - task: test:{{.CPP_BUILD_SYSTEM}}
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"

  test:bazel:
    desc: 'Run tests with Bazel{{if and (ne OS "windows") (eq .CPP_COMPILER "g++")}} and generate coverage{{end}}'
    cmds:
      - cmd: |
          {{if eq OS "windows"}}
          echo "‚úÖ Running tests (coverage not supported on Windows)..."
          bazel test //tests/... --test_output=errors
          {{else}}
            {{if eq .CPP_COMPILER "g++"}}
          echo "üìä Running tests with coverage for g++..."
          bazel coverage //tests/... --config=coverage --nocache_test_results
            {{else}}
          echo "‚úÖ Running tests (coverage only supported with g++)..."
          bazel test //tests/... --test_output=errors
            {{end}}
          {{end}}
      - task: test:gen-coverage
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"

  test:cmake:
    desc: "Run tests with coverage using CMake"
    cmds:
      - cd {{.CPP_BUILD_DIR}} && ctest --output-on-failure {{if eq .CPP_COMPILER "msvc"}}-C Debug{{end}}
      - task: test:gen-coverage
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"

  test:xmake:
    desc: "Run tests with coverage using XMake"
    cmds:
      - xmake run {{.CPP_PROJECT_NAME}}-tests
      - task: test:gen-coverage
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"

  test:gen-coverage:
    desc: "Generate coverage report"
    cmds:
      - cmd: |
          echo ""
          echo "üìä Generating coverage report..."
          echo ""
      # Windows: Skip coverage for MSVC only, allow clang++
      - cmd: |
          {{if eq OS "windows"}}
            {{if eq .CPP_COMPILER "msvc"}}
          echo "‚ö†Ô∏è Coverage generation is not supported with MSVC on Windows. Skipping."
          echo ""
          exit 0
            {{end}}
          {{end}}
        platforms: [windows]
      # Bazel: g++ only, use lcov
      - cmd: |
          {{if eq .CPP_BUILD_SYSTEM "bazel"}}
            {{if ne .CPP_COMPILER "g++"}}
          echo "‚ö†Ô∏è Bazel coverage is only supported with g++. Skipping."
          echo ""
          exit 0
            {{end}}

          if [ ! -f "bazel-out/_coverage/_coverage_report.dat" ]; then
            echo "‚ö†Ô∏è No coverage data found. Did coverage run successfully?"
            exit 0
          fi

          if ! command -v genhtml >/dev/null 2>&1; then
            echo "‚ö†Ô∏è genhtml not found. Install: sudo apt-get install lcov"
            exit 1
          fi

          # Generate inline coverage summary
          if command -v lcov >/dev/null 2>&1; then
            echo "üìä Coverage Summary (Source Files Only):"
            echo ""

            # Show detailed per-file coverage, filtering out test files from display
            lcov --list bazel-out/_coverage/_coverage_report.dat 2>/dev/null | \
              tail -n +3 | \
              grep -v -E "(tests/|integration/|unit/)" | \
              grep -v "^Executed" | \
              grep -v "^Test cases" || \
              lcov --list bazel-out/_coverage/_coverage_report.dat 2>/dev/null | tail -n +3
            echo ""
          fi

          # Generate HTML report
          mkdir -p .coverage
          if ! genhtml bazel-out/_coverage/_coverage_report.dat \
            --output-directory .coverage \
            --branch-coverage \
            --highlight \
            --legend \
            --ignore-errors empty \
            --quiet 2>/dev/null; then
            echo "‚ö†Ô∏è Failed to generate coverage report. The coverage data may be empty."
            echo "   This can happen if no source files were instrumented."
            echo "   Check that your source files are in the correct directories."
            exit 0
          fi

          echo ""
          echo "‚úÖ HTML coverage report: .coverage/index.html"
          echo ""
          exit 0
          {{end}}
        platforms: [darwin, linux]
      # CMake/XMake: Skip MSVC, use gcovr
      - cmd: |
          {{if or (eq .CPP_BUILD_SYSTEM "cmake") (eq .CPP_BUILD_SYSTEM "xmake")}}
            {{if eq .CPP_COMPILER "msvc"}}
          echo "‚ö†Ô∏è Coverage is not supported with MSVC. Skipping."
          echo ""
          exit 0
            {{end}}

          if ! command -v gcovr >/dev/null 2>&1; then
            echo "‚ö†Ô∏è gcovr not found. Install: uv pip install gcovr"
            exit 1
          fi

          echo "üìä Coverage Summary:"
          echo ""

          # Determine gcov executable based on compiler
          GCOV_EXEC="gcov"
          {{if eq .CPP_COMPILER "clang++"}}
          # Use llvm-cov with gcov-compatible interface for clang++
          if command -v llvm-cov >/dev/null 2>&1; then
            GCOV_EXEC="llvm-cov gcov"
            echo "‚ÑπÔ∏è Using llvm-cov for clang++ coverage"
          else
            echo "‚ö†Ô∏è Warning: llvm-cov not found, coverage may fail with clang++"
          fi
          {{else if eq .CPP_COMPILER "g++"}}
          # Try to find the matching gcov for g++
          CXX_VERSION=$({{.CPP_COMPILER}} -dumpversion | cut -d. -f1)
          if command -v "gcov-$CXX_VERSION" >/dev/null 2>&1; then
            GCOV_EXEC="gcov-$CXX_VERSION"
            echo "‚ÑπÔ∏è Using $GCOV_EXEC to match {{.CPP_COMPILER}} version $CXX_VERSION"
          else
            echo "‚ö†Ô∏è Warning: gcov-$CXX_VERSION not found, using default gcov (may cause version mismatch)"
          fi
          {{end}}

          gcovr --root . \
            --filter 'src/.*' --filter 'include/.*' \
            --exclude 'tests/.*' --exclude 'build/_deps/.*' \
            --gcov-executable "$GCOV_EXEC" \
            --gcov-ignore-errors=no_working_dir_found \
            --txt
          echo ""

          mkdir -p .coverage
          gcovr --root . \
            --filter 'src/.*' --filter 'include/.*' \
            --exclude 'tests/.*' --exclude 'build/_deps/.*' \
            --gcov-executable "$GCOV_EXEC" \
            --gcov-ignore-errors=no_working_dir_found \
            --html-details .coverage/index.html 2>/dev/null
          echo "‚úÖ HTML coverage report: .coverage/index.html"
          echo ""
          {{end}}
    silent: true

  # ============================================================================
  # Development Tools
  # ============================================================================

  run:
    desc: "Run application"
    deps:
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
    cmds:
      - |
        echo "üèÉ Running application..."
        {{.__TF_COMMAND_WRAPPER}} '{{
          .__TF_VAR_PREFIX}}BUILD_PATH="{{if eq .CPP_BUILD_SYSTEM "bazel"}}bazel-out{{else}}{{.CPP_BUILD_DIR}}{{end}}";{{.__TF_DUMMY_SPACE}}{{
            if ne OS "windows"}}./$BUILD_PATH/**/{{.CPP_PROJECT_NAME}}{{
            else}}(Get-ChildItem ./$BUILD_PATH{{if eq .CPP_BUILD_SYSTEM "bazel"}}/*-opt/bin{{end}} -Recurse -Filter {{
              .CPP_PROJECT_NAME}}.exe | Select-Object -First 1).FullName | ForEach-Object { & $_ }{{
            end}}'

  debug:
    desc: "Run application with debugger (requires gdb)"
    cmds:
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_TYPE: "Debug"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
      - |
        if ! command -v gdb >/dev/null 2>&1; then
          echo "‚ùå gdb not found. Please install gdb first."
          exit 1
        fi
        {{if eq .CPP_BUILD_SYSTEM "bazel"}}
            gdb bazel-bin/{{.CPP_PROJECT_NAME}}
        {{else}}
            gdb ./{{.CPP_BUILD_DIR}}/**/{{.CPP_PROJECT_NAME}}
        {{end}}

  # ============================================================================
  # Documentation Tasks
  # ============================================================================

  docs:
    desc: "Build documentation"
    cmds:
      - mkdocs build

  docs:serve:
    desc: "Serve documentation locally with live reload"
    cmds:
      - |
        echo "üìö Starting documentation server..."
        echo "üìñ Open http://127.0.0.1:8000 in your browser"
        mkdocs serve

  docs:deploy:
    desc: "Deploy documentation to GitHub Pages"
    cmds:
      - mkdocs gh-deploy --force

  # ============================================================================
  # Validation Tasks
  # ============================================================================

  validate:
    cmds:
      - cmd: |
          {{range $build := .__TF_VALIDATION_CPP_BUILD_SYSTEMS | splitList " "}}
            task validate:by:build-system CPP_BUILD_SYSTEM="{{$build}}"
          {{end}}
    desc: "Run integration tests for all build systems"
    silent: true

  validate:by:build-system:
    cmds:
      - cmd: |
          bs='{{.CPP_BUILD_SYSTEM}}'
          hl="{{.__TF_HEADER_LINE}}"
          {{range $compiler := .__TF_VALIDATION__CPP_COMPILERS | splitList " "}}
            echo $hl
            echo "üèÉ Running validation for $bs with {{$compiler}}..."
            echo $hl
            echo ""
            task validate:by:build-system:compiler \
              CPP_BUILD_SYSTEM="$bs" \
              CPP_COMPILER="{{$compiler}}"
          {{end}}
    desc: "Run CI pipeline for specific build system"
    silent: true

  validate:by:build-system:compiler:
    cmds:
      - task: clean
        vars:
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
      - task: build
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_TYPE: "{{.CPP_BUILD_TYPE}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
      - task: run
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
      - task: clean
      - task: test
        vars:
          CPP_BUILD_SYSTEM: "{{.CPP_BUILD_SYSTEM}}"
          CPP_BUILD_DIR: "{{.CPP_BUILD_DIR}}"
          CPP_COMPILER: "{{.CPP_COMPILER}}"
          CPP_PROJECT_NAME: "{{.CPP_PROJECT_NAME}}"
      - cmd: |
          echo ""
          echo "{{.__TF_HEADER_LINE}}"
          echo "‚úÖ Validation successful for {{.CPP_BUILD_SYSTEM}} with {{.CPP_COMPILER}}"
          echo "{{.__TF_HEADER_LINE}}"
          echo ""
    desc: "Run CI pipeline for specific build system and compiler"
    silent: true

  # ============================================================================
  # Python/UV Package Management Tasks
  # ============================================================================

  uv:refresh:
    desc: "Refresh all Python packages (update dependencies)"
    cmds:
      - |
        echo "üîÑ Refreshing Python packages..."
        uv sync --upgrade
        echo "‚úì Packages refreshed"

  uv:sync:
    desc: "Install Python dependencies (including pre-commit)"
    cmds:
      - |
        echo "üì¶ Installing Python dependencies..."
        uv sync
        echo "ü™ù Installing pre-commit hooks..."
        pre-commit install
        echo "‚úì Python environment ready"
  # valgrind:
  #   desc: "Run application with Valgrind"
  #   deps:
  #     - task: which
  #       vars:
  #         COMMAND: "valgrind"
  #     - task: build
  #       vars: { CPP_BUILD_TYPE: "Debug" }
  #   cmds:
  #     - mise exec -- valgrind --leak-check=full --show-leak-kinds=all ./{{.CPP_BUILD_DIR}}/src/{{.CPP_PROJECT_NAME}}
