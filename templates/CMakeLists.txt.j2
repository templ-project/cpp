cmake_minimum_required(VERSION 3.20)

# =============================================================================
# Cross-compilation / Architecture configuration
# Must be set BEFORE project() to take effect
# =============================================================================
{% if target_arch %}
{% if target_arch == "x86_64" %}
# Target: x86_64 (64-bit Intel/AMD)
if(APPLE)
    set(CMAKE_OSX_ARCHITECTURES "x86_64" CACHE STRING "Build for x86_64" FORCE)
endif()
{% elif target_arch == "aarch64" %}
# Target: aarch64 (64-bit ARM)
if(APPLE)
    set(CMAKE_OSX_ARCHITECTURES "arm64" CACHE STRING "Build for arm64" FORCE)
endif()
{% elif target_arch == "i686" %}
# Target: i686 (32-bit Intel/AMD) - not supported on macOS
{% endif %}
{% endif %}

project(
    {{ project_name }}
    VERSION 1.0.0
    DESCRIPTION "A C++ Bootstrap/Template project using modern tools and best practices"
    LANGUAGES CXX
)

# Set C++ standard
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# Additional compiler flags for cross-compilation (non-Apple platforms)
{% if target_arch %}
{% if target_arch == "x86_64" %}
if(NOT APPLE)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m64")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m64")
endif()
{% elif target_arch == "aarch64" %}
if(NOT APPLE)
    # For Linux cross-compilation, set target triple
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --target=aarch64-linux-gnu")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --target=aarch64-linux-gnu")
endif()
{% elif target_arch == "i686" %}
if(APPLE)
    message(FATAL_ERROR "32-bit builds are not supported on macOS")
else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -m32")
    set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -m32")
endif()
{% endif %}
{% endif %}

# Configure output directories to use {{ build_dir }}/${CMAKE_BUILD_TYPE}
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${CMAKE_BUILD_TYPE})
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${CMAKE_BUILD_TYPE})
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${CMAKE_BUILD_TYPE})

# Also set per-configuration output directories
foreach(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
    string(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG_UPPER)
    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG_UPPER} ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${OUTPUTCONFIG})
    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG_UPPER} ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${OUTPUTCONFIG})
    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG_UPPER} ${CMAKE_SOURCE_DIR}/{{ build_dir }}/${OUTPUTCONFIG})
endforeach()

# Compiler-specific options
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    # Base flags for Clang (warnings but not errors for third-party code compatibility)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")

    # Use libc++ on macOS
    if(APPLE)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -stdlib=libc++")

        # For non-system clang (e.g., mise-managed LLVM), we need to explicitly add
        # the library path and link libraries since the LLVM distribution includes its own libc++
        get_filename_component(CLANG_BIN_DIR "${CMAKE_CXX_COMPILER}" DIRECTORY)
        get_filename_component(CLANG_ROOT_DIR "${CLANG_BIN_DIR}" DIRECTORY)
        set(CLANG_LIB_DIR "${CLANG_ROOT_DIR}/lib")

        if(EXISTS "${CLANG_LIB_DIR}/libc++.dylib")
            # Use the libc++ from the clang installation - must explicitly link both libraries
            set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -L${CLANG_LIB_DIR} -lc++ -lc++abi -Wl,-rpath,${CLANG_LIB_DIR}")
        else()
            # Fall back to system libc++
            set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -lc++ -lc++abi")
        endif()
    endif()

    # Debug flags with sanitizers (works on all platforms with Clang)
    set(CMAKE_CXX_FLAGS_DEBUG "-g -O0")
    if(WIN32)
        # Windows: Skip sanitizers for now due to runtime library dependencies
        # TODO: Enable when ASAN runtime libraries are properly configured
        # set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address")
    else()
        # Linux/macOS: enable both address and undefined behavior sanitizers
        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fsanitize=address,undefined")
    endif()

    # Enable coverage for Debug builds with clang++ (Linux/macOS only)
    {% if build_type == 'Debug' and compiler == 'clang++' %}
    if(NOT WIN32)
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")
    endif()
    {% endif %}

    set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG")
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wextra -Wpedantic")
    set(CMAKE_CXX_FLAGS_DEBUG "-g -O0")
    set(CMAKE_CXX_FLAGS_RELEASE "-O3 -DNDEBUG")

    # Enable coverage for Debug builds with g++
    {% if build_type == 'Debug' and compiler == 'g++' %}
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} --coverage")
    set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --coverage")
    {% endif %}
elseif(CMAKE_CXX_COMPILER_ID STREQUAL "MSVC")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4")
    set(CMAKE_CXX_FLAGS_DEBUG "/Od /Zi")
    set(CMAKE_CXX_FLAGS_RELEASE "/O2 /DNDEBUG")
endif()

# Enable testing
enable_testing()

# Fetch dependencies using FetchContent
include(FetchContent)

# Google Test
FetchContent_Declare(
    googletest
    GIT_REPOSITORY https://github.com/google/googletest.git
    GIT_TAG v1.14.0
    GIT_SHALLOW TRUE
)

# For Windows: Prevent overriding the parent project's compiler/linker settings
set(gtest_force_shared_crt ON CACHE BOOL "" FORCE)

# Disable warnings in GTest to avoid build errors from third-party code
set(CMAKE_CXX_FLAGS_BACKUP "${CMAKE_CXX_FLAGS}")
if(CMAKE_CXX_COMPILER_ID MATCHES "Clang" OR CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -w")  # Disable all warnings for GTest
endif()

# Make GTest available
FetchContent_MakeAvailable(googletest)

# Restore original flags for our project code
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS_BACKUP}")

# Include directories
include_directories(include)

# Add subdirectories
add_subdirectory(src)
add_subdirectory(tests)

# Install configuration
include(GNUInstallDirs)
install(TARGETS {{ project_name }}
    RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
)

install(DIRECTORY include/
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
    FILES_MATCHING PATTERN "*.h" PATTERN "*.hpp"
)
